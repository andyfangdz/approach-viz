# Rendering Performance

- Vertical reference lines for path points are batched into a single `lineSegments` geometry per path segment (final/transition/missed) to reduce draw-call count.
- Heavy scene primitives (`ApproachPath`, `AirspaceVolumes`, `TerrainWireframe`, `ApproachPlateSurface`, `SatelliteSurface`) are memoized.
- The top-level scene wrapper (`SceneCanvas`) is memoized so selector typing/collapse state updates in the header do not re-render the Three.js subtree.
- Airport/approach combobox query text is managed inside `HeaderControls`, keeping high-frequency search keystrokes out of `AppClient` state and preventing avoidable scene updates.
- The canvas uses capped DPR (`1..1.5`) and high-performance WebGL context hints.
- Live ADS-B traffic polling is throttled to a fixed interval (`5s`) through a same-origin proxy to the Rust runtime endpoint (`/v1/traffic/adsbx`) and bounded by viewport-centric query radius/aircraft limit to avoid full-feed client downloads.
- Live ADS-B traffic does a one-time initial trace backfill request (default `3 min`) when overlay context/history changes, and merges trace backfill into existing tracks when history retention is increased; subsequent `5s` polls fetch current targets only.
- Live ADS-B trail history is time-pruned by the user-selected retention window (`1..30 minutes`) to cap per-aircraft polyline growth.
- Live ADS-B callsign labels are optional and rendered only when the `Show Traffic Callsigns` toggle is enabled to avoid persistent label clutter.
- Live ADS-B marker meshes reuse shared sphere geometry/material instances rather than allocating one geometry/material pair per aircraft marker.
- Live ADS-B aircraft markers are rendered via a single `InstancedMesh`, reducing per-aircraft React/Three mesh overhead while still updating positions every poll.
- MRMS volumetric weather is polled at a slower cadence (`~120s`) from a pre-ingested Rust weather service; the Next.js route only proxies upstream payloads (or the client can fetch upstream directly when configured), removing per-poll GRIB decode/listing work from the request path.
- MRMS query responses use compact binary wire payloads (`application/vnd.approach-viz.mrms.v2`) instead of large JSON voxel arrays, reducing transfer size and decode overhead for dense scans.
- MRMS v2 query serialization performs server-side brick merging (same phase + quantized dBZ + contiguous spans) so broad precipitation regions are represented by fewer, larger prisms while preserving full coverage.
- MRMS server-side query filtering is performed against in-memory tile-indexed snapshots with precomputed phase/layer metadata, keeping per-request work bounded to AOI selection and tuple serialization.
- MRMS overlay polling keeps rendering the last successful payload when the API returns a transient error payload, avoiding abrupt disappear/reappear flicker.
- MRMS overlay clears prior payload immediately when airport context changes (ref lat/lon or threshold inputs), preventing stale weather columns from lingering at the previous location while the next poll is in flight.
- MRMS voxels render through one `InstancedMesh` (shared box geometry/material) with per-instance transforms/colors and per-instance dBZ-driven alpha (via `InstancedBufferAttribute` + `onBeforeCompile` shader patch), keeping draw calls bounded even during dense precipitation events while ensuring low-intensity echoes are nearly transparent and high-intensity cores remain visually prominent.
- MRMS client rendering no longer applies client-side voxel decimation; instead, instanced-mesh capacity scales to payload size so every server record is rendered.
- MRMS shader patch applies soft edge falloff + vertical glow shaping so merged bricks remain visually smooth (aurora-like) instead of hard-edged cubes.
- MRMS rendering uses dataset-derived voxel dimensions (X/Y footprint from grid spacing + per-level altitude thickness), so visual cell size tracks source resolution instead of a heuristic overlap factor.
- In-scene `Html` labels (waypoints/holds/runways/turn constraints/callsigns) use a capped `zIndexRange` so app UI overlays (selectors/options/legend) stay visually on top.
- Three.js resources allocated imperatively in hooks (`TubeGeometry`, airspace extrusions/edges, traffic marker buffers, plate textures) are explicitly disposed in effect cleanup paths to prevent GPU memory growth across scene updates.
- Airspace extrusions are built in base altitude units and Y-scaled at the group level, avoiding expensive airspace geometry rebuilds when only `verticalScale` changes.
